<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Busan AR Portal</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<style>
body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
#tap-overlay { position: absolute; top:0; left:0; width:100%; height:100%; z-index:10; display:flex; flex-direction:column; align-items:center; justify-content:center; background:rgba(0,0,0,0.8); color:white; }
#btn-start { padding:15px 40px; font-size:20px; background:#bf55ec; color:white; border:none; border-radius:50px; }
#dist-ui { position:absolute; bottom:30px; width:100%; text-align:center; color:white; font-weight:bold; z-index:5; pointer-events:none; }
</style>
</head>
<body>

<div id="tap-overlay">
    <h2>釜山 没入体験</h2>
    <button id="btn-start">開始</button>
</div>

<div id="dist-ui">位置: 0.0m</div>

<script>

let scene, camera, renderer, portals = [];
let moveZ = 0, targetZ = 0, isTouch = false;
let targetRotX = 0, targetRotY = 0;
let currentRotX = 0, currentRotY = 0;

const loader = new THREE.TextureLoader();

function init() {

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth/window.innerHeight,
        0.1,
        1000
    );
    camera.position.set(0, 1.6, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);

    // ✅ 展示安定化
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));

    document.body.appendChild(renderer.domElement);

    // カメラ背景
    navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
        .then(s => {
            const v = document.createElement('video');
            v.srcObject = s;
            v.setAttribute('playsinline','');
            v.play();
            scene.background = new THREE.VideoTexture(v);
        });

    const confs = [
        {z:-5, img:'./day_1.jpg', col:0x87CEEB},
        {z:-15, img:'./day_2.jpg', col:0x8B4513},
        {z:-25, img:'./night_1.jpg', col:0xbf55ec}
    ];

    confs.forEach(c => {

        const group = new THREE.Group();
        group.position.set(0, 1.5, c.z);

        const dGeo = new THREE.PlaneGeometry(1.2, 3.5);

        const L = new THREE.Mesh(dGeo,
            new THREE.MeshBasicMaterial({color:c.col, transparent:true})
        );
        L.position.set(-0.6, 0, 0.1);

        const R = new THREE.Mesh(dGeo,
            new THREE.MeshBasicMaterial({color:c.col, transparent:true})
        );
        R.position.set(0.6, 0, 0.1);

        const tex = loader.load(c.img);
        tex.repeat.set(1, -1);
        tex.offset.set(0, 1);

        const pGeo = new THREE.CylinderGeometry(
            5, 5, 8, 32, 1, true,
            Math.PI*0.65, Math.PI*0.7
        );

        const pMat = new THREE.MeshBasicMaterial({
            map:tex,
            side:THREE.BackSide,
            transparent:true,
            opacity:0
        });

        const panel = new THREE.Mesh(pGeo, pMat);
        panel.position.set(0, 0, -4.5);

        group.add(L, R, panel);
        scene.add(group);

        portals.push({group, L, R, panel, z:c.z});
    });

    document.addEventListener('touchstart', e => {
        if(e.target.id !== 'btn-start') isTouch = true;
    });

    document.addEventListener('touchend', () => isTouch = false);

    // ✅ ジャイロ平滑化
    window.addEventListener('deviceorientation', e => {
        targetRotY = e.alpha * Math.PI / 180;
        targetRotX = (e.beta - 90) * Math.PI / 180;
    });

    animate();
}

// ✅ 回転スムージング関数
function updateCameraRotation(){
    const smooth = 0.08;
    currentRotX += (targetRotX - currentRotX) * smooth;
    currentRotY += (targetRotY - currentRotY) * smooth;

    camera.rotation.order = "YXZ";
    camera.rotation.y = currentRotY;
    camera.rotation.x = currentRotX;
}

function animate() {

    requestAnimationFrame(animate);

    if (isTouch) targetZ += 0.02;

    moveZ += (targetZ - moveZ) * 0.1;
    camera.position.z = -moveZ;

    // ✅ 安定回転適用
    updateCameraRotation();

    portals.forEach(p => {

        const d = Math.abs(camera.position.z - p.z);

        if (d < 8.0) {

            p.group.visible = true;
            p.panel.material.opacity = 1;

            if (d < 2.5) {
                p.L.position.x = THREE.MathUtils.lerp(p.L.position.x, -2.5, 0.05);
                p.R.position.x = THREE.MathUtils.lerp(p.R.position.x, 2.5, 0.05);
                if (d < 0.8)
                    p.L.material.opacity = p.R.material.opacity = 0;
            } else {
                p.L.position.x = THREE.MathUtils.lerp(p.L.position.x, -0.6, 0.05);
                p.R.position.x = THREE.MathUtils.lerp(p.R.position.x, 0.6, 0.05);
                p.L.material.opacity = p.R.material.opacity = 1;
            }

        } else {

            p.group.visible = false;
            if (camera.position.z < p.z)
                p.panel.material.opacity = 0;
        }
    });

    document.getElementById('dist-ui').innerText =
        `位置: ${moveZ.toFixed(1)}m`;

    renderer.render(scene, camera);
}

document.getElementById('btn-start').onclick = () => {
    init();
    document.getElementById('tap-overlay').style.display='none';
};

</script>
</body>
</html>
