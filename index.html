<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Busan Particle Warp</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); color: #fff; display: flex; justify-content: center; align-items: center; z-index: 1000; cursor: pointer; }
        #whiteout { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #fff; opacity: 0; pointer-events: none; z-index: 900; }
        .btn { padding: 15px 30px; border: 2px solid #fff; border-radius: 50px; font-size: 1.2rem; }
    </style>
</head>
<body>

    <div id="overlay" onclick="requestPermission()">
        <div class="btn">釜山へテイクオフ</div>
    </div>
    <div id="whiteout"></div>

<script>
let scene, camera, renderer, skyMesh, planeMesh, doorL, doorR, sphere, particles;
let isWarping = false, warpStartTime = 0;
let hasArrived = false, phase = 'flight';
const loader = new THREE.TextureLoader();

function requestPermission() {
    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().then(state => {
            if (state === 'granted') startApp();
        });
    } else { startApp(); }
}

function startApp() {
    document.getElementById('overlay').style.display = 'none';
    init();
}

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.rotation.order = 'YXZ';

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 1. 背景 (sora.jpg)
    loader.load('./sora.jpg', (tex) => {
        tex.wrapS = THREE.RepeatWrapping;
        skyMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 40), new THREE.MeshBasicMaterial({ map: tex }));
        skyMesh.position.z = -25;
        scene.add(skyMesh);
    });

    // 2. 飛行機 (hikouki.png) - X軸180度回転
    loader.load('./hikouki.png', (tex) => {
    planeMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(8, 5),
        new THREE.MeshBasicMaterial({ 
            map: tex, 
            transparent: true, 
            side: THREE.DoubleSide // 両面描画を許可
        })
    );
    planeMesh.position.set(-14, 0, -12);
    planeMesh.rotation.x = Math.PI; // X軸180度回転
    scene.add(planeMesh);
});

    // 3. 扉
    const doorGeo = new THREE.PlaneGeometry(10, 6);
    const doorMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
    doorL = new THREE.Mesh(doorGeo, doorMat);
    doorR = new THREE.Mesh(doorGeo, doorMat);
    doorL.position.set(8, 3, -15);
    doorR.position.set(8, -3, -15);
    scene.add(doorL, doorR);

    // 4. 光の粒子 (初期は非表示)
    const pGeo = new THREE.BufferGeometry();
    const pCount = 500;
    const pPos = new Float32Array(pCount * 3);
    for(let i=0; i<pCount*3; i++) pPos[i] = (Math.random()-0.5) * 10;
    pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
    const pMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1, transparent: true, opacity: 0 });
    particles = new THREE.Points(pGeo, pMat);
    scene.add(particles);

    // 5. 釜山遠景 (day_2.jpg)
    loader.load('./day_2.jpg', (tex) => {
        sphere = new THREE.Mesh(
            new THREE.SphereGeometry(600, 64, 32).scale(-1, 1, 1),
            new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0 })
        );
        scene.add(sphere);
    });

    window.addEventListener('deviceorientation', (e) => {
        if (hasArrived && e.alpha) {
            camera.rotation.set((e.beta - 90) * Math.PI / 180, e.alpha * Math.PI / 180, 0);
        }
    });

    const trigger = () => { if(phase==='flight') { phase='warp'; warpStartTime = performance.now(); } };
    window.addEventListener('touchstart', trigger);
    window.addEventListener('mousedown', trigger);

    animate();
}

function animate() {
    requestAnimationFrame(animate);
    const time = performance.now() * 0.001;
    const whiteoutEl = document.getElementById('whiteout');

    if (phase === 'flight') {
        if (skyMesh) skyMesh.material.map.offset.x += 0.0005;
        if (planeMesh) {
            planeMesh.position.x += 0.015;
            planeMesh.position.y = Math.sin(time) * 0.1;
        }
    } 
    else if (phase === 'warp') {
        const elapsed = performance.now() - warpStartTime;
        doorL.position.y = Math.min(8, doorL.position.y + 0.15);
        doorR.position.y = Math.max(-8, doorR.position.y - 0.15);

        if (planeMesh) {
            let isNearDoor = (planeMesh.position.x > 0);
            let speed = isNearDoor ? 1.8 : 0.08;
            planeMesh.position.x += speed;
            planeMesh.position.z -= speed * 0.6;

            // 扉に触れたら粒子を出す
            if (isNearDoor) {
                particles.material.opacity = 1;
                particles.position.set(planeMesh.position.x, planeMesh.position.y, planeMesh.position.z);
                particles.rotation.y += 0.1;
            }

            if (planeMesh.position.x > 18) {
                phase = 'whiteout';
                warpStartTime = performance.now();
            }
        }
    } 
    else if (phase === 'whiteout') {
        const elapsed = performance.now() - warpStartTime;
        whiteoutEl.style.opacity = elapsed < 100 ? elapsed / 100 : 1;

        if (elapsed > 500) { // 0.5秒に短縮
            scene.remove(planeMesh, skyMesh, doorL, doorR, particles);
            phase = 'arrival';
            warpStartTime = performance.now();
        }
    } 
    else if (phase === 'arrival') {
        const elapsed = performance.now() - warpStartTime;
        whiteoutEl.style.opacity = 1 - (elapsed / 2500);
        if (sphere) sphere.material.opacity = elapsed / 2500;
        camera.position.z = THREE.MathUtils.lerp(0, -60, elapsed / 8000);

        if (elapsed > 2500) {
            hasArrived = true;
            whiteoutEl.style.display = 'none';
        }
    }
    renderer.render(scene, camera);
}
</script>
</body>
</html>

