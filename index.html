<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Busan Side Entry Portal</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); color: #fff; display: flex; justify-content: center; align-items: center; z-index: 1000; cursor: pointer; }
        .btn { padding: 15px 30px; border: 2px solid #fff; border-radius: 50px; font-size: 1.2rem; }
    </style>
</head>
<body>

    <div id="overlay" onclick="requestPermission()">
        <div class="btn">釜山へのフライトを開始</div>
    </div>

<script>
let scene, camera, renderer, skyMesh, planeMesh, doorL, doorR, sphere;
let isWarping = false, warpStartTime = 0;
let hasArrived = false;
const loader = new THREE.TextureLoader();

function requestPermission() {
    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().then(state => {
            if (state === 'granted') startApp();
        });
    } else { startApp(); }
}

function startApp() {
    document.getElementById('overlay').style.display = 'none';
    init();
}

function init() {
    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.rotation.order = 'YXZ';

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 1. 空の背景 (sora.jpg)
    loader.load('./sora.jpg', (tex) => {
        tex.wrapS = THREE.RepeatWrapping;
        skyMesh = new THREE.Mesh(new THREE.PlaneGeometry(50, 30), new THREE.MeshBasicMaterial({ map: tex }));
        skyMesh.position.z = -20;
        scene.add(skyMesh);
    });

    // 2. 飛行機のPNG (hikouki.png) - 左側に配置
    loader.load('./hikouki.png', (tex) => {
        planeMesh = new THREE.Mesh(new THREE.PlaneGeometry(6, 4), new THREE.MeshBasicMaterial({ map: tex, transparent: true }));
        planeMesh.position.set(-8, 0, -10); 
        scene.add(planeMesh);
    });

    // 3. 90度回転した平行な扉 (画面右側に配置)
    const doorGeo = new THREE.PlaneGeometry(8, 5); // 横長にして「壁」のように
    const doorMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
    doorL = new THREE.Mesh(doorGeo, doorMat);
    doorR = new THREE.Mesh(doorGeo, doorMat);
    
    // 扉を平行（少し斜め）に配置
    doorL.position.set(5, 2.5, -12);
    doorR.position.set(5, -2.5, -12);
    scene.add(doorL, doorR);

    // 4. 釜山の全天球 (day_2.jpg)
    loader.load('./day_2.jpg', (tex) => {
        sphere = new THREE.Mesh(
            new THREE.SphereGeometry(100, 64, 32).scale(-1, 1, 1),
            new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0 })
        );
        scene.add(sphere);
    });

    // ジャイロ制御
    window.addEventListener('deviceorientation', (e) => {
        if (hasArrived && e.alpha) {
            camera.rotation.set((e.beta - 90) * Math.PI / 180, e.alpha * Math.PI / 180, 0);
        }
    });

    window.addEventListener('touchstart', triggerWarp);
    window.addEventListener('mousedown', triggerWarp);

    animate();
}

function triggerWarp() {
    if (!isWarping && !hasArrived) {
        isWarping = true;
        warpStartTime = performance.now();
    }
}

function animate() {
    requestAnimationFrame(animate);
    const time = performance.now() * 0.001;

    if (!hasArrived) {
        // 通常飛行中
        if (skyMesh) skyMesh.material.map.offset.x += 0.001;
        if (planeMesh && !isWarping) {
            planeMesh.position.y = Math.sin(time * 1.5) * 0.15; // 浮遊感
            planeMesh.position.x = THREE.MathUtils.lerp(planeMesh.position.x, -5, 0.01);
        }
    }

    if (isWarping) {
        const elapsed = performance.now() - warpStartTime;
        const alpha = Math.min(elapsed / 2000, 1); // 2秒でワープ

        // 扉が上下に開く（平行なシャッターのように）
        doorL.position.y = 2.5 + (alpha * 5);
        doorR.position.y = -2.5 - (alpha * 5);

        // 飛行機が「扉の隙間」へ斜めに吸い込まれる
        if (planeMesh) {
            planeMesh.position.x += 0.2; // 右へ
            planeMesh.position.z -= 0.1; // 奥へ（扉の中へ）
            planeMesh.rotation.y = alpha * 0.5; // 少し扉の方へ傾く
            
            // 扉の向こう側（z=-12付近）に到達したら消去
            if (planeMesh.position.z <= -12) {
                scene.remove(planeMesh);
                planeMesh = null;
            }
        }

        // 景色切り替え
        if (!planeMesh) {
            if (skyMesh) skyMesh.material.opacity = Math.max(0, skyMesh.material.opacity - 0.1);
            if (sphere) sphere.material.opacity = Math.min(1, sphere.material.opacity + 0.1);
            
            if (alpha > 0.9) {
                hasArrived = true;
                isWarping = false;
                scene.remove(doorL, doorR, skyMesh);
            }
        }
    }
    renderer.render(scene, camera);
}
</script>
</body>
</html>
