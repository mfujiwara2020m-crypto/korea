<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Busan Portal - Deep Depth Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); color: #fff; display: flex; justify-content: center; align-items: center; z-index: 1000; cursor: pointer; }
        #whiteout { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #fff; opacity: 0; pointer-events: none; z-index: 900; }
        .btn { padding: 15px 40px; border: 2px solid #fff; border-radius: 50px; font-size: 1.2rem; }
    </style>
</head>
<body>

    <div id="overlay" onclick="requestPermission()">
        <div class="btn">釜山への旅をはじめる</div>
    </div>
    <div id="whiteout"></div>

<script>
let scene, camera, renderer, skyMesh, planeMesh, doorL, doorR, sphere, particles;
let warpStartTime = 0;
let hasArrived = false;
let phase = 'flight'; 
const loader = new THREE.TextureLoader();

function requestPermission() {
    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().then(state => {
            if (state === 'granted') startApp();
        });
    } else { startApp(); }
}

function startApp() {
    document.getElementById('overlay').style.display = 'none';
    init();
}

function init() {
    scene = new THREE.Scene();
    // 1. 【奥行きUP】FOVを110に広げ、描画距離を5000に拡張
    camera = new THREE.PerspectiveCamera(110, window.innerWidth / window.innerHeight, 0.1, 5000);
    camera.rotation.order = 'YXZ';

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 空
    loader.load('./sora.jpg', (tex) => {
        tex.wrapS = THREE.RepeatWrapping;
        skyMesh = new THREE.Mesh(new THREE.PlaneGeometry(80, 50), new THREE.MeshBasicMaterial({ map: tex }));
        skyMesh.position.z = -30;
        scene.add(skyMesh);
    });

    // 飛行機 (左右反転)
    loader.load('./hikouki.png', (tex) => {
        planeMesh = new THREE.Mesh(
            new THREE.PlaneGeometry(8, 5),
            new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide })
        );
        planeMesh.position.set(-15, 0, -12);
        planeMesh.scale.x = -1; 
        scene.add(planeMesh);
    });

    // 扉
    const doorGeo = new THREE.PlaneGeometry(12, 8);
    const doorMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    doorL = new THREE.Mesh(doorGeo, doorMat);
    doorR = new THREE.Mesh(doorGeo, doorMat);
    doorL.position.set(10, 4, -18);
    doorR.position.set(10, -4, -18);
    scene.add(doorL, doorR);

    // 粒子
    const pGeo = new THREE.BufferGeometry();
    const pPos = new Float32Array(600 * 3);
    for(let i=0; i<600*3; i++) pPos[i] = (Math.random()-0.5) * 15;
    pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
    particles = new THREE.Points(pGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.12, transparent: true, opacity: 0 }));
    scene.add(particles);

    // 2. 【奥行きUP】球体の半径を1500に拡大して遠景を強調
    loader.load('./day_2.jpg', (tex) => {
        sphere = new THREE.Mesh(
            new THREE.SphereGeometry(1500, 64, 32).scale(-1, 1, 1),
            new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0 })
        );
        scene.add(sphere);
    });

    window.addEventListener('deviceorientation', (e) => {
        if (hasArrived && e.alpha) {
            camera.rotation.set((e.beta - 90) * Math.PI / 180, e.alpha * Math.PI / 180, 0);
        }
    });

    const startWarp = () => { if(phase==='flight') { phase='warp'; warpStartTime = performance.now(); } };
    window.addEventListener('touchstart', startWarp);
    window.addEventListener('mousedown', startWarp);

    animate();
}

function animate() {
    requestAnimationFrame(animate);
    const time = performance.now() * 0.001;
    const whiteoutEl = document.getElementById('whiteout');

    if (phase === 'flight') {
        if (skyMesh) skyMesh.material.map.offset.x += 0.0006;
        if (planeMesh) {
            planeMesh.position.x += 0.015;
            planeMesh.position.y = Math.sin(time * 0.8) * 0.15;
        }
    } 
    else if (phase === 'warp') {
        const elapsed = performance.now() - warpStartTime;
        if (elapsed > 1200) { 
            doorL.position.y += 0.2;
            doorR.position.y -= 0.2;
        }

        if (planeMesh) {
            let isAccelerating = (planeMesh.position.x > 7);
            let speed = isAccelerating ? 2.0 : 0.08;
            planeMesh.position.x += speed;
            planeMesh.position.z -= speed * 0.5;

            if (isAccelerating) {
                particles.material.opacity = 1;
                particles.position.set(planeMesh.position.x, planeMesh.position.y, planeMesh.position.z);
            }

            if (planeMesh.position.x > 25) {
                phase = 'whiteout';
                warpStartTime = performance.now();
            }
        }
    } 
    else if (phase === 'whiteout') {
        const elapsed = performance.now() - warpStartTime;
        whiteoutEl.style.opacity = elapsed < 100 ? elapsed / 100 : 1;

        if (elapsed > 500) {
            scene.remove(planeMesh, skyMesh, doorL, doorR, particles);
            phase = 'arrival';
            warpStartTime = performance.now();
        }
    } 
    else if (phase === 'arrival') {
        const elapsed = performance.now() - warpStartTime;
        whiteoutEl.style.opacity = 1 - (elapsed / 3000);
        if (sphere) sphere.material.opacity = elapsed / 3000;

        // 3. 【奥行きUP】遠くから近づく幅を -300 まで大きく
        camera.position.z = THREE.MathUtils.lerp(0, -300, elapsed / 10000);

        if (elapsed > 3000) {
            hasArrived = true;
            whiteoutEl.style.display = 'none';
        }
    }
    renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
