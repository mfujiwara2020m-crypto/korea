<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Busan Ultimate Warp</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); color: #fff; display: flex; justify-content: center; align-items: center; z-index: 1000; cursor: pointer; }
        #whiteout { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #fff; opacity: 0; pointer-events: none; z-index: 900; }
        .btn { padding: 15px 30px; border: 2px solid #fff; border-radius: 50px; font-size: 1.2rem; }
    </style>
</head>
<body>

    <div id="overlay" onclick="requestPermission()">
        <div class="btn">釜山への旅を開始する</div>
    </div>
    <div id="whiteout"></div>

<script>
let scene, camera, renderer, skyMesh, planeMesh, doorL, doorR, sphere;
let isWarping = false, warpStartTime = 0;
let hasArrived = false;
let phase = 'flight'; // flight -> warp -> whiteout -> arrival
const loader = new THREE.TextureLoader();

function requestPermission() {
    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().then(state => {
            if (state === 'granted') startApp();
        });
    } else { startApp(); }
}

function startApp() {
    document.getElementById('overlay').style.display = 'none';
    init();
}

function init() {
    scene = new THREE.Scene();
    // 初期は広角(FOV 90)にして遠景を強調
    camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.rotation.order = 'YXZ';

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // 1. 空 (sora.jpg)
    loader.load('./sora.jpg', (tex) => {
        tex.wrapS = THREE.RepeatWrapping;
        skyMesh = new THREE.Mesh(new THREE.PlaneGeometry(60, 40), new THREE.MeshBasicMaterial({ map: tex }));
        skyMesh.position.z = -25;
        scene.add(skyMesh);
    });

    // 2. 飛行機 (hikouki.png) - 最初は鼻先だけ見せる
    loader.load('./hikouki.png', (tex) => {
        planeMesh = new THREE.Mesh(new THREE.PlaneGeometry(8, 5), new THREE.MeshBasicMaterial({ map: tex, transparent: true }));
        planeMesh.position.set(-14, 0, -12); // 左端に隠しておく
        scene.add(planeMesh);
    });

    // 3. 平行な扉 (右側に横たわる)
    const doorGeo = new THREE.PlaneGeometry(10, 6);
    const doorMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
    doorL = new THREE.Mesh(doorGeo, doorMat);
    doorR = new THREE.Mesh(doorGeo, doorMat);
    doorL.position.set(8, 3, -15);
    doorR.position.set(8, -3, -15);
    scene.add(doorL, doorR);

    // 4. 釜山遠景 (day_2.jpg)
    loader.load('./day_2.jpg', (tex) => {
        // 球体を大きくして遠くに見せる
        sphere = new THREE.Mesh(
            new THREE.SphereGeometry(500, 64, 32).scale(-1, 1, 1),
            new THREE.MeshBasicMaterial({ map: tex, transparent: true, opacity: 0 })
        );
        scene.add(sphere);
    });

    window.addEventListener('deviceorientation', (e) => {
        if (hasArrived && e.alpha) {
            camera.rotation.set((e.beta - 90) * Math.PI / 180, e.alpha * Math.PI / 180, 0);
        }
    });

    window.addEventListener('touchstart', () => { if(phase==='flight') phase='warp'; warpStartTime = performance.now(); });
    window.addEventListener('mousedown', () => { if(phase==='flight') phase='warp'; warpStartTime = performance.now(); });

    animate();
}

function animate() {
    requestAnimationFrame(animate);
    const time = performance.now() * 0.001;
    const whiteoutEl = document.getElementById('whiteout');

    if (phase === 'flight') {
        if (skyMesh) skyMesh.material.map.offset.x += 0.0005;
        if (planeMesh) {
            // ゆっくりと中央へ進む
            planeMesh.position.x += 0.015;
            planeMesh.position.y = Math.sin(time) * 0.1;
        }
    } 
    else if (phase === 'warp') {
        const elapsed = performance.now() - warpStartTime;
        
        // 扉がゆっくり開き始める
        doorL.position.y = Math.min(8, doorL.position.y + 0.1);
        doorR.position.y = Math.max(-8, doorR.position.y - 0.1);

        if (planeMesh) {
            // 扉に近づくまでは中速、扉(x=0付近)に来たらマッハ加速
            let speed = (planeMesh.position.x > 0) ? 1.5 : 0.08;
            planeMesh.position.x += speed;
            planeMesh.position.z -= speed * 0.5; // 奥へ吸い込まれる

            // 完全に吸い込まれたらホワイトアウトへ
            if (planeMesh.position.x > 15) {
                phase = 'whiteout';
                warpStartTime = performance.now();
            }
        }
    } 
    else if (phase === 'whiteout') {
        const elapsed = performance.now() - warpStartTime;
        
        // パッと白くなり、1秒維持
        if (elapsed < 200) whiteoutEl.style.opacity = elapsed / 200;
        else whiteoutEl.style.opacity = 1;

        if (elapsed > 1200) {
            // 背景リセット
            scene.remove(planeMesh, skyMesh, doorL, doorR);
            phase = 'arrival';
            warpStartTime = performance.now();
        }
    } 
    else if (phase === 'arrival') {
        const elapsed = performance.now() - warpStartTime;
        
        // 徐々に景色が見える (3秒かけてフェード)
        whiteoutEl.style.opacity = 1 - (elapsed / 3000);
        if (sphere) sphere.material.opacity = elapsed / 3000;

        // カメラがゆっくり街へ近づくアニメーション
        camera.position.z = THREE.MathUtils.lerp(0, -50, elapsed / 10000);

        if (elapsed > 3000) {
            hasArrived = true;
            whiteoutEl.style.display = 'none';
        }
    }

    renderer.render(scene, camera);
}
</script>
</body>
</html>
